## java数据结构和算法

### 1、数组

### 2、简单排序
    (1) 冒泡排序 : 小的往上冒
    (2) 选择排序
    (3) 插入排序

### 3、栈和队列
    (1) 栈 : 先进后出,后进先出
    (2) 队列 : 先进先出，后进后出
    
### 4、链表

### 5、双端链表和双向链表
    (1) 双端链表：联表中保留着对最后一个链结点引用
        从头部插入：要对链表进行判断，如果为空则设置尾结点为新添加的结点
        从尾部插入：如果链表为空，则直接设置头结点为新添加的结点，否则设置尾结点的后一个结点为新添加结点
        从头部删除：判断头结点是否为下一个结点，如果没有则是指结点为null
    (2) 双向链表：每个结点除了保存了对下一个结点的引用，同时还保存对前一个结点的引用
        从头部插入：要对链表进行判断，如果为空则设置尾结点为新添加结点。如果不为空，还需设置筒节点的前一个结点为新添加的结点
        从尾部插入：如果链表为空，则直接设置头结点为新添加结点，否则设置尾结点的后一个结点为新添加结点。同时设置新添加的结点的前一个结点为尾结点
        从头部删除：判断头结点是否有下一个结点，如果没有则设置结点为null，否则设置头结点的下一个结点的previous为null
        
### 6、递归
    
    递归：一种方法调用自己的编程技术
    
### 7、希尔排序

    希尔排序基于插入排序，并添加了一些新的特性，从而大大地提高插入排序的执行效率
    
      希尔排序通过加大排序中元素的间隔，并对这些间隔的元素进行插入排序，从而使得数据可以大幅度移动。
    当完成间隔排序后，希尔排序会减少数据间隔再进行排序。依次进行下去。
    
### 8、快速排序

    快速排序通过将一个数据划分成两个子数组，然后通过递归调用自身为每个子数组进行快速排序来实现。
    
    设定关键字，将比关键字小的数据放在一组，比关键字大的放在另外一组。
    
    设置数组最右端的数据为关键字。
    
### 9、树

    从根节点到任何节点只有一条路径

  有序数组插入数据和删除数据慢；
  链表查找数据慢；
  在树中能非常快速的查找数据项、插入数据项和删除数据项；
  
#### (1) 二叉树
  
    树的每一个结点最多只能有两个子节点的树
    
  A、插入节点
    从根节点开始查找一个相应的节点，这个节点将成为新插入节点的父节点。当父节点找到后，通过判断
  新节点的值比父节点的值得大小来决定是连接到左子节点还是右子节点。
  
  B、查找节点
    从根节点开始查找，如果查找的节点值比当前节点的值小，则继续查找其左子树，否则查找其右子树。
    
  C、遍历树
    遍历树是根据一个特定顺序访问树的每一个节点，根据顺序的不同分为：前序、中序和后序三种。
    * 前序遍历：
      访问根节点；前序遍历左子树；前序遍历右子树。
    * 中序遍历：
      中序遍历左子树；访问根节点；中序遍历右子树。
    * 后序遍历：
      后序遍历左子树；后序遍历右子树；访问根节点。
      
  D、删除节点
    删除考虑三种情况：
    * 该节点是叶子结点，没有子节点：要删除叶子结点，只需要改变该节点的父节点的引用值，将指向该节点的引用设置为null；  
    * 该节点有一个子节点：改变父节点的引用，将其直接指向要删除节点的子节点；
    * 该节点有两个子节点：需要使用它的中序后继来替代该节点；
    
#### (2) 红黑树
  
  二叉树如果插入有序数据的话，速度就会很慢
  平衡树：插入随机的数据；
  非平衡树：插入有序的数据；
  
  A、红黑树规则：
    * 每个节点不是红色的就是黑色的；
    * 根是黑色的；
    * 如果节点时红色的，则它的子节点必须是黑色的；
    * 从根节点到叶节点的每条路径，必须包含相同数目的黑色节点；
    
  B、纠正规则，将不符合红黑规则的树纠正为红黑树：
    * 改变节点的颜色；
    * 执行旋转操作；


### 10、哈希表
  
  (1) 哈希表是一种数据结构，它提供了快速的插入操作和查找操作。其基于数组实现。
  
  (2) 哈希化
    直接将关键字作为索引；
    将单词转换成索引：
      a、将字母转换成ASCII码，然后进行相加；
      b、幂的连乘；
      c、压缩可选值；
  
  (3) 压缩后仍可能出现的问题：
    冲突，不能保证每个单词都映射到数组的空白单元；
    解决办法：
      a、开放地址法:当冲突发生时，通过查找数组的一个空位，并将数据填入，而不再用哈希函数得到的数组下标。
      b、链地址法：在哈希表每个单元中设置链表。某个数据项的关键字还是像通常一样映射到哈希表的单元中，
      而数据项本身插入到单元的链表中。
         
         
### 11、图
  
  (1) 
  
  
